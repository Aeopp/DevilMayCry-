#include "stdafx.h"
#include "MapTool.h"

#include "TestObject.h"
#include "MapToolPivot.h"
#include <fstream>
#include <ostream>
#include <iostream>

#include <commdlg.h>

/*
ImGui 아닌 함수들 모음
*/
//#include "Renderer.h"

using namespace std;

MapTool::MapTool()
	:m_iPeekingCnt(0)
	, m_fPivotMoveSpeed(0.1f)
	, m_bReadyNameTable(false)
{
	ZeroMemory(m_bPropsOption, sizeof(bool) * (int)MapToolProps::ePropsOption::End);
	ZeroMemory(m_bHoveredMaptool, sizeof(bool) * (int)eWindowID::End);
}

void MapTool::Free()
{
	Scene::Free();
}

MapTool* MapTool::Create()
{
	MapTool* pInstance = new MapTool();
	return pInstance;
}
//피킹함수에서 무조건 적으로 넣어줘야함 UI 클릭이 오브젝트 생성 하면 됨 
bool MapTool::IsHoverUIWindow()
{
	for (int i = 0; i < (int)eWindowID::End; ++i)
		if (m_bHoveredMaptool[i])
			return true;
	return false;
}

void MapTool::HelpMarker(const char* desc)
{
	ImGui::TextDisabled("(?)");
	if (ImGui::IsItemHovered())
	{
		ImGui::BeginTooltip();
		ImGui::PushTextWrapPos(ImGui::GetFontSize() * 35.0f);
		ImGui::TextUnformatted(desc);
		ImGui::PopTextWrapPos();
		ImGui::EndTooltip();
	}
}


void MapTool::SelectFile()
{
	TCHAR   szPropsPath[MAX_PATH] = L"";
	TCHAR   szPropsName[MAX_PATH] = L"";

	std::filesystem::path rootPath = std::filesystem::absolute("./"); //솔루션 디렉토리 경로  따로저장 

	OPENFILENAME open;
	memset(&open, 0, sizeof(OPENFILENAME));
	open.lStructSize = sizeof(OPENFILENAME);
	open.hwndOwner = g_hWnd;
	open.lpstrFilter = L"All Files(*.*)\0*.*\0";
	open.nMaxFile = nFileNameMaxLen;
	open.nMaxFileTitle = nFileNameMaxLen;
	open.lpstrFile = szPropsPath;
	open.lpstrFileTitle = szPropsName;
	if (0 != GetOpenFileName(&open))
	{
		m_strSelectFBXName = szPropsName;
		bool bFindID = false;
		m_iTableID = ERR_ID;

		//테이블시트에서 value값 뒤져서 키값을 찾음 ...
		for (auto pair : m_mapFBXNameTable)
		{
			if (!lstrcmpW(m_strSelectFBXName.c_str(), pair.second.sFileName.c_str()))
			{
				m_iTableID = pair.first; // 저장해서 생성할때 이걸 m_iTableID를 세터로 넣어줌 
				bFindID = true;
				break;
			}
		}

		//혹시 리소스 파일 추가해놓고 테이블 시트를 예전걸로 로드했을경우 못찾으니 확인용 
		if (bFindID == false)
		{
			PRINT_LOG(L"File Name Not exist NameTable", __FUNCTIONW__);
			return;
		}
	}

	SetCurrentDirectory(rootPath.wstring().c_str()); // 저장한걸로 교체 
}

void MapTool::ClearMultiPeeking()
{
	if (!m_listMultiPeeking.empty())
	{
		for (auto& pObj : m_listMultiPeeking)
			pObj.lock()->m_bMultiPeekPeeking = false;

		m_listMultiPeeking.clear();
	}
}

HRESULT MapTool::LoadScene()
{
	Scene::LoadScene();
	ImGuiStyle& style = ImGui::GetStyle();
	style.Colors[ImGuiCol_PopupBg] = ImVec4(0, 0, 0, 255);
	m_iPeekingCnt = 0;
	m_iTableID = 0;
	m_strSelectFBXName = L"";
	m_fFOV = 90.f;
	UpdateProj();
	D3DXMatrixIdentity(&m_matCameraWorld);
	m_vCameraSpeed = { 20.f,10.f };
	m_vCameraPos = vZero;
	m_vRot = vZero;
	m_fCameraAngSpeed = 100.f;
	m_fPivotMoveSpeed = 10.f;
	m_pPivot =  AddGameObject<MapToolPivot>();
	return S_OK;
}

HRESULT MapTool::Awake()
{
	Scene::Awake();

	return S_OK;
}

HRESULT MapTool::Start()
{
	Scene::Start();

	return S_OK;
}

std::wstring MapTool::convertToWstring(const std::string& s)
{
	std::wstring Convert;
	Convert.assign(std::begin(s), std::end(s));
	return Convert;
}

std::string MapTool::convertToString(const std::wstring& s)
{
	std::string Convert;
	Convert.assign(std::begin(s), std::end(s));
	return Convert;
}
HRESULT MapTool::Update(const float _fDeltaTime)
{
	Scene::Update(_fDeltaTime);

	ShowMapTool(); //맵툴 
	ShowPivotOption(); // 피봇 
	ShowCameraOption(); // 카메라 ui 윈도우 
	HotKey(); // 단축키 모음 
	CameraControl(_fDeltaTime);
	PivotControl(_fDeltaTime);
	return S_OK;
}

HRESULT MapTool::LateUpdate(const float _fDeltaTime)
{
	Scene::LateUpdate(_fDeltaTime);
	UpdateView(); //뷰행렬 장치에 입력 
	return S_OK;
}

bool MapTool::NewFBXNameTable(const _TCHAR* pPath)
{
	// new 라 필요 없겠네. 이것도 디렉토리 창으로 할거면 .. 
	/*if(!std::filesystem::exists(pPath))
	{
		PRINT_LOG(L"Error Path", __FUNCTIONW__);
		return false;
	}*/

	m_mapFBXNameTable.clear();
	if (FAILED(CreateMeshNameTable(PROPSPATH)))
	{
		PRINT_LOG(L"Failed!", __FUNCTIONW__);
		return false;
	}
	using namespace rapidjson;
	std::filesystem::path TargetPath = pPath;
	StringBuffer StrBuf;
	PrettyWriter<StringBuffer> js(StrBuf);
	UINT iID = 0;
	js.StartObject();
	js.Key("NameTable");
	js.StartArray();
	{
		for (auto& pair : m_mapFBXNameTable)
		{
			js.StartObject();
			{
				js.Key("ID");
				js.Uint(pair.first);
				js.Key("FileLocation");
				js.String(convertToString(pair.second.sFileLocation).c_str());
				js.Key("FileName");
				js.String(convertToString(pair.second.sFileName).c_str());
			}
			js.EndObject();
		}
	}
	js.EndArray();
	js.EndObject();
	std::ofstream Of{ TargetPath };
	Of << StrBuf.GetString();

	return true;
}

bool MapTool::LoadFBXnametable(const _TCHAR* pPath)
{

	//세이브 파일 체크 
	if (!std::filesystem::exists(pPath))
	{
		PRINT_LOG(L"Error Path", __FUNCTIONW__);
		return false;
	}

	m_mapFBXNameTable.clear();
	using namespace rapidjson;
	std::ifstream Is{ pPath };
	if (!Is.is_open())
	{
		PRINT_LOG(L"Error Open", __FUNCTIONW__);
		return false;
	}
	IStreamWrapper Isw(Is);
	Document doc;
	doc.ParseStream(Isw);
	if (doc.HasParseError())
	{
		PRINT_LOG(L"Error Parse", __FUNCTIONW__);
		return false;
	}

	Value& TableVal = doc["NameTable"]; //단일 오브젝트 세이브파일임 
	const auto& TableArr = TableVal.GetArray();
	PATHINFO tInfo;
	for (auto TableIter = TableArr.Begin(); TableIter != TableArr.End(); ++TableIter)
	{
		tInfo.sFileLocation = convertToWstring(TableIter->FindMember("FileLocation")->value.GetString());
		tInfo.sFileName = convertToWstring(TableIter->FindMember("FileName")->value.GetString());
		m_mapFBXNameTable.emplace(TableIter->FindMember("ID")->value.GetUint(), tInfo);
	}

	return true;
}

void MapTool::SaveProps()
{
	//Get Path
	TCHAR   szPropsPath[MAX_PATH] = L"";
	TCHAR   szPropsName[MAX_PATH] = L"";
	std::filesystem::path rootPath = std::filesystem::absolute("./"); //루트 경로 빼놓음 
	OPENFILENAME open;
	memset(&open, 0, sizeof(OPENFILENAME));
	open.lStructSize = sizeof(OPENFILENAME);
	open.hwndOwner = g_hWnd;
	open.lpstrFilter = L"Json Files(*.json)\0*.json\0";
	open.nMaxFile = nFileNameMaxLen;
	open.nMaxFileTitle = nFileNameMaxLen;
	open.lpstrFile = szPropsPath;
	open.lpstrFileTitle = szPropsName;
	if (0 != GetSaveFileName(&open)) {}; //저장경로 
	SetCurrentDirectory(rootPath.wstring().c_str()); // open 쓰면 디렉토리경로 변경되니깐 위에서 미리 따로 저장한걸 세팅

	// 아 짤려니깐 json 문법 까먹어서 터짐 다시 짜주셈 
	//Save json
	//m_mapObjDatas 저장 형식이 ID , list<GameOjbect >형식 
	// 맵 순회하면서 ID 저장 하고 list 순회하면서 transform 값들 저장  bool 값 저장 
	using namespace rapidjson;
	std::filesystem::path TargetPath = std::filesystem::relative(szPropsPath);;
	TargetPath += L".json";
	StringBuffer StrBuf;
	PrettyWriter<StringBuffer> js(StrBuf);

	js.StartObject();
	{
		js.Key("LoadingList");
		js.StartArray();
		{
			for (auto& pair : m_mapObjDatas) // pair second is list 
			{
				js.Key("ID");
				js.Uint(pair.first); // 정수형을 키값으로 파일 이름대신에 사용 테이블 탐색을 문자열보단 빠를 거같음 
				js.StartObject();
				{
					js.StartArray();
					{
						for (auto& pObj : pair.second) // list의 원소 Props 객체 
						{
							js.Key("Scale"); 
							js.Double(pObj.lock()->Get_Trans().lock()->GetScale().x);

							js.Key("Rotate");
							js.StartArray();
							{
								js.Double(pObj.lock()->Get_Trans().lock()->GetRotation().x);
								js.Double(pObj.lock()->Get_Trans().lock()->GetRotation().y);
								js.Double(pObj.lock()->Get_Trans().lock()->GetRotation().z);
							}
							js.EndArray();
							js.Key("Position");
							js.StartArray();
							{
								js.Double(pObj.lock()->Get_Trans().lock()->GetPosition().x);
								js.Double(pObj.lock()->Get_Trans().lock()->GetPosition().y);
								js.Double(pObj.lock()->Get_Trans().lock()->GetPosition().z);
							}
							js.EndArray(); // end of positon
							// 기본적인 월드 정보 끝 
							js.Key("option");
							js.StartArray();
							for (int i = 0; i < (int)MapToolProps::ePropsOption::End; ++i)
								js.Bool(pObj.lock()->m_bOption[i]);
							js.EndArray();
						}
					}js.EndArray(); // end of id ojbect
				}js.EndObject();
			}
		}js.EndArray();
	}js.EndObject();
	std::ofstream Of{ TargetPath };
	Of << StrBuf.GetString();
}

HRESULT MapTool::LoadBaseMap()
{
	std::filesystem::path rootPath = std::filesystem::absolute("./"); //루트 경로 빼놓음 
	TCHAR   szPropsPath[MAX_PATH] = L"";
	OPENFILENAME open;
	memset(&open, 0, sizeof(OPENFILENAME));
	open.lStructSize = sizeof(OPENFILENAME);
	open.hwndOwner = g_hWnd;
	open.lpstrFilter = L"All Files(*.*)\0*.*\0";
	open.nMaxFile = nFileNameMaxLen;
	open.lpstrFile = szPropsPath;

	if (0 != GetOpenFileName(&open))
	{
		m_pBaseMap = AddGameObject<MapToolProps>();
		m_pBaseMap.lock()->m_strFilePath = szPropsPath;
	}
	SetCurrentDirectory(rootPath.wstring().c_str()); // open 쓰면 디렉토리경로 변경되니깐 위에서 미리 따로 저장한걸 세팅
	return S_OK;
}

void MapTool::CreateProps()
{
	//
	if (m_bCreateLock)
	{
		PRINT_LOG(L"Create Lock", L"Check Setting");
		return;
	}
	//추가 후 테이블에서 경로 값 넣어서 fbx 로드하게 해주고 아이디 넣어주고 
	if (m_eCreateOption == eCreatePosition::PeekingPos)
	{
		Vector3 vPeekPos = vZero;
		//피킹 지점 추가 후 삭제 
		// ex m_pbBase.lock()->피킹지정 반환 
		//m_pCurSelectObj = AddGameObject<MapToolProps>();
		//m_pCurSelectObj.lock()->SetFBXPath(m_mapFBXNameTable[m_iTableID].sFileLocation);
		//m_pCurSelectObj.lock()->m_iPropsID = m_iTableID;	
		//m_pCurSelectObj.lock()->Get_Trans().lock()->SetPos(vPeekPos);
	}
	else if(m_eCreateOption == eCreatePosition::PivotPos)
	{
		m_pCurSelectObj = AddGameObject<MapToolProps>();
		//생성위치를 피봇으로 ./  생성한건 바로  수정 할 수 있도록 하는게 편하겠지?  
		m_pCurSelectObj.lock()->m_strFilePath = m_strPeekingName = m_mapFBXNameTable[m_iTableID].sFileLocation;
		m_pCurSelectObj.lock()->m_iPropsID = m_iTableID;
		m_pCurSelectObj.lock()->Get_Trans().lock()->SetPosition(m_pPivot.lock()->Get_Trans().lock()->GetPosition());
	}
	else
	{
		PRINT_LOG(L"CreatOption Not Select", L"Check Setting");
		return;
	}

	//map에 중복확인 
	auto iterFind = m_mapObjDatas.find(m_iTableID);

	if (iterFind == m_mapObjDatas.end())
	{
		iterFind = m_mapObjDatas.emplace(m_iTableID, std::list<std::weak_ptr<MapToolProps>>()).first;
		iterFind->second.emplace_back(m_pCurSelectObj);
	}
	else
		iterFind->second.emplace_back(m_pCurSelectObj);
}


HRESULT MapTool::CreateMeshNameTable(std::wstring strStartPath)
{
	//d2d 때 파일 탐색 로직 
	if (std::filesystem::exists(strStartPath))
	{
		PRINT_LOG(L"Erorr Path Check plz", __FUNCTIONW__);
		return E_FAIL;
	}

	WIN32_FIND_DATA tFindData;
	std::wstring tCurPath = strStartPath + L"/*.*";
	int keyValue = 0;
	HANDLE hFind = FindFirstFile(tCurPath.c_str(), &tFindData);
	if (hFind == INVALID_HANDLE_VALUE)
	{
		PRINT_LOG(L"Error Path", __FUNCTIONW__);
		FindClose(hFind);
		return E_FAIL;
	}
	BOOL bContinue = false;
	do
	{
		if (TEXT('.') == tFindData.cFileName[0]) // . , .. 패스 
		{
			bContinue = FindNextFile(hFind, &tFindData);
			continue;
		}
		else if (FILE_ATTRIBUTE_DIRECTORY == tFindData.dwFileAttributes) // 디렉토리면 재귀 
		{
			CreateMeshNameTable(strStartPath + L'/' + tFindData.cFileName);
		}
		else
		{
			if (FILE_ATTRIBUTE_SYSTEM == tFindData.dwFileAttributes) // 시스템 파일 패스 
			{
				bContinue = FindNextFile(hFind, &tFindData);
				continue;
			};

			//이상하게 ImGui ini 이  생성이 됨   나중에 fbx 만 폴더에다 모으고 텍스쳐 한폴더에 모으면  tga 는 빼도 됨 
			std::wstring CheckExtension = tFindData.cFileName;
			if (std::wstring::npos != CheckExtension.find(L".tga") || std::wstring::npos != CheckExtension.find(L".ini")) 
			{
				bContinue = FindNextFile(hFind, &tFindData);
				continue;
			}

			PATHINFO tInfo;
			tInfo.sFileLocation = strStartPath +L"/" +  tFindData.cFileName;
			tInfo.sFileName = tFindData.cFileName;
			m_mapFBXNameTable.emplace(keyValue++, tInfo);
		}

		bContinue = FindNextFile(hFind, &tFindData);
	} while (bContinue);

	FindClose(hFind);
	return S_OK;
}

void MapTool::ApplyPropsOption()
{
	//check box 누를 때마다 호출 되는 함수 그냥 bool 적용해줌 
	if (m_ePeekType == ePeekingType::Single)
	{
		for (int i = 0; i < (int)MapToolProps::ePropsOption::End; ++i)
		{
			m_pCurSelectObj.lock()->m_bOption[i] = m_bPropsOption[i];
		}
	}
	else // Multi
	{
		for (auto& pObj : m_listMultiPeeking)
		{
			for (int i = 0; i < (int)MapToolProps::ePropsOption::End; ++i)
			{
				pObj.lock()->m_bOption[i] = m_bPropsOption[i];
			}
		}
	}
}

void MapTool::UpdateProj()
{
	D3DXMatrixPerspectiveFovLH(&m_matProj, D3DXToRadian(m_fFOV), (float)g_nWndCX / g_nWndCY, 0.1f, 500.f);
	g_pDevice->SetTransform(D3DTS_PROJECTION, &m_matProj);
}

void MapTool::UpdateView()
{
	Matrix a;
	D3DXMatrixIdentity(&m_matCameraWorld);
	m_matCameraWorld *= (*D3DXMatrixRotationX(&a, D3DXToRadian(m_vRot.x)));
	m_matCameraWorld *= (*D3DXMatrixRotationY(&a, D3DXToRadian(m_vRot.y)));
	m_matCameraWorld *= (*D3DXMatrixRotationZ(&a, D3DXToRadian(m_vRot.z)));
	m_matCameraWorld *= (*D3DXMatrixTranslation(&a, m_vCameraPos.x,m_vCameraPos.y,m_vCameraPos.z));
	D3DXMatrixInverse(&m_matView, NULL, &m_matCameraWorld);
	g_pDevice->SetTransform(D3DTS_VIEW, &m_matView);
}

void MapTool::CameraControl(const float& _fDeltaTime)
{
	if (IsHoverUIWindow())
		return;

	Vector3 vLook(0.f, 0.f, 0.f);
	memcpy_s(&vLook, sizeof(Vector3), m_matCameraWorld.m[2], sizeof(Vector3));
	Vector3 vRight(0.f, 0.f, 0.f);
	memcpy_s(&vRight, sizeof(Vector3), m_matCameraWorld.m[0], sizeof(Vector3));
	D3DXVec3Normalize(&vLook, &vLook);
	D3DXVec3Normalize(&vRight, &vRight);
	vLook*= _fDeltaTime;
	vRight*= _fDeltaTime;

	if (Input::GetKey(DIK_W))
		m_vCameraPos += vLook * m_vCameraSpeed.x;
	if (Input::GetKey(DIK_S))
		m_vCameraPos += -vLook * m_vCameraSpeed.x;
	if (Input::GetKey(DIK_A))
		m_vCameraPos += -vRight * m_vCameraSpeed.x;
	if (Input::GetKey(DIK_D))
		m_vCameraPos += vRight * m_vCameraSpeed.x;
	if (Input::GetKey(DIK_Z))
		m_vCameraPos += Vector3(0, -1, 0) * m_vCameraSpeed.y * _fDeltaTime;
	if (Input::GetKey(DIK_C))
		m_vCameraPos += Vector3(0, 1, 0) * m_vCameraSpeed.y * _fDeltaTime;

	if (Input::GetMouse(MOUSEBUTTON::DIM_R))
	{
		long	dwMouseMove = 0;

		if (dwMouseMove = Input::GetMouseMove(MOUSEAXIS::DIM_Y))
			m_vRot.x += dwMouseMove * m_fCameraAngSpeed * _fDeltaTime;
		if (dwMouseMove = Input::GetMouseMove(MOUSEAXIS::DIM_X))
			m_vRot.y += dwMouseMove * m_fCameraAngSpeed * _fDeltaTime;

		POINT	ptMouse{ g_nWndCX >> 1, g_nWndCY >> 1 };

		ClientToScreen(g_hWnd, &ptMouse);
		SetCursorPos(ptMouse.x, ptMouse.y);
	}
}

void MapTool::HotKey()
{
	if (Input::GetKey(DIK_R))
		m_eWorkType = eWorkOption::Create;
	if (Input::GetKey(DIK_T))
		m_eWorkType = eWorkOption::Delete;
	if (Input::GetKey(DIK_Y))
		m_eWorkType = eWorkOption::Modify;
	if (Input::GetKeyDown(DIK_SPACE) && m_eWorkType == eWorkOption::Create && m_eCreateOption == eCreatePosition::PivotPos)
		CreateProps();
}

void MapTool::PivotControl(const float& fDeltaTime)
{
	Vector3 vPivotPos   = m_pPivot.lock()->Get_Trans().lock()->GetPosition();  
	Vector3 vLook(0.f, 0.f, 0.f);
	memcpy_s(&vLook, sizeof(Vector3), m_matCameraWorld.m[2], sizeof(Vector3));
	Vector3 vRight(0.f, 0.f, 0.f);
	memcpy_s(&vRight, sizeof(Vector3), m_matCameraWorld.m[0], sizeof(Vector3));
	D3DXVec3Normalize(&vLook, &vLook);
	D3DXVec3Normalize(&vRight, &vRight);
	vLook *= fDeltaTime;
	vRight *= fDeltaTime;
	// 카메라 룩 라이트 가지고 움직일려니 y값 들어가서 이상하게 움직임 y 값 제거 
	vLook.y = 0;
	vRight.y = 0;

	if (Input::GetKey(DIK_LEFT)) // x Axis minus
	{
		vPivotPos += vRight *  -m_fPivotMoveSpeed;
		std::cout << vPivotPos.x << std::endl;
	}
	 if (Input::GetKey(DIK_RIGHT)) // x Axis plus 
		vPivotPos+= vRight * m_fPivotMoveSpeed;
	 if (Input::GetKey(DIK_UP))  // z Axis plus
		vPivotPos += vLook * m_fPivotMoveSpeed;
	 if (Input::GetKey(DIK_DOWN)) // z Axis minus
		vPivotPos += vLook *  -m_fPivotMoveSpeed;
	 if (Input::GetKey(DIK_HOME))// y Axis plus
		vPivotPos += Vector3(0,1,0) * m_fPivotMoveSpeed * fDeltaTime;
	 if (Input::GetKey(DIK_END))	 // y Axis minus
		vPivotPos+= Vector3(0, -1, 0) * m_fPivotMoveSpeed  * fDeltaTime;

	m_pPivot.lock()->Get_Trans().lock()->SetPosition(vPivotPos);
}


void MapTool::MousePeeking()
{
	// 피킹자체가 아직 안되지만 대략적으로 틀은 이럼  

	if (Input::GetMouse(MOUSEBUTTON::DIM_L)) // 클릭시 
	{
		switch (m_eWorkType) // Create Delete Modify 에 따라 작동 
		{
		case MapTool::eWorkOption::Create:
			//if(m_pBaseMap.lock() -> 피킹 g호출 )
			//{
			//	AddProps();
			//}
			break;
		case MapTool::eWorkOption::Delete:
			for (auto& pair : m_mapObjDatas)
			{
				for (auto& pObj : pair.second)
				{
					//if (pObj.lock()->피킹 호출)
					//{
					//	//pObj.lock()->Destroy()
						//케스팅 디파인 잡아놓음  몬가 불편함 
					//	//ConvertGameObjPtr(x) static_cast<std::weak_ptr<GameObject>>(x) 
					//}
				}
			}
			break;
		case MapTool::eWorkOption::Modify:
			for (auto& pair : m_mapObjDatas)
			{
				for (auto& pObj : pair.second)
				{
					//if(pObj.lock()-> 피킹 호출 ) // 피킹성공 
					{
						if (m_ePeekType == ePeekingType::Single)
						{
							m_pCurSelectObj = pObj;
							//UI에 옵션을 피킹한 오브젝트걸로 동기화 
							for (int i = 0; i < (int)MapToolProps::ePropsOption::End; ++i)
								m_bPropsOption[i] = pObj.lock()->m_bOption[i];
						}
						else  // multi
						{
							if (pObj.lock()->m_bMultiPeekPeeking == false)
							{
								pObj.lock()->m_bMultiPeekPeeking = true;
							}
						}
					}
				}
			}
			break;
		case MapTool::eWorkOption::End:
			break;
		}
	}
}

